---
title: "Integrating datasets"
output: md_document
date: "2023-10-25"
---

# Intro to data integration

A recurrent theme in -omics work is the notion of "batch effects". This term originates from the days of microarrays, when there would be slight differences in annealing times and/or affinities between runs of microarrays. "Batch effects" has now become a blanket coloquial term to generally mean anything related to a technical artifact that arises between samples or runs. The key is that it is not a true biological signal, but instead something that should be "normalized away" to allow real biological signals to shine.

Statistically, it is straightforward to control for a batch effect: if you are using a linear model, for example, you could include the "batch" as a covariate. The challenge really arises with high-dimensional approaches such as principal component analysis or visualizing data in a UMAP - often times, when batch effects are present, visualizations are distorted or largely driven by these batch effects. There are well-documented strategies for removing batch effect in microarrays or bulk RNAseq data, which we will not discuss here. 

For single-cell RNAseq analysis, we can use one simple approach called "data integration" that is robustly implemented in Seurat. To demonstrate this, we will use healthy donor PBMC that have been generated with either 10X Genomics 3' v2 chemistry or 5' v1 chemistry. The chemistry, in this case, is the batch effect we are trying to remove. 

# Prerequisites 

First, we need to create a project directory and download the relevant data. 

# Load packages 

First, we will load the necessary packages.

```{r load_packages, echo=FALSE}

library(Seurat)
library(dplyr) # from the tidyverse
library(patchwork) # for combining ggplots 

```

# Create a Seurat object

Next, we will load the raw data and create a Seurat object from it.

```{r load_data}

# Read in the data
pbmc_data <- Read10X("~/Desktop/pbmc3k_vignette/pbmc3k/filtered_gene_bc_matrices/hg19")

# Check out the data - it's a sparse matrix 
pbmc_data[1:10,1:10]

# Look at some specific genes 
pbmc_data[c("CD3D", "TCL1A", "MS4A1"), 1:30]

# Create a Seurat object from the data 
pbmc_ser <- CreateSeuratObject(counts=pbmc_data,project="pbmc3k",min.cells=3,min.features=200)

# Check out the constructed Seurat object
pbmc_ser

# Metadata is automatically generated and can be viewed 
head(pbmc_ser@meta.data)

```

# Quality control and filtering

Prior to beginning any analysis, we need to perform a quality control across the dataset.

Commonly used criteria for QC are:
1) Low number of unique genes per cell - low number of genes and/or counts likely means that the cell was ruptured or dying during library generation and should be removed.
2) Percentage of genes aligning to mitochondrial reads per cell - a high frequency of mitochondrial reads per cell also indicates poor cell quality during library generation 

Any cells outside of these criteria should be excluded. 

It's important to always use dataset specific cutoffs (rather than general cutoffs) because these values depend on the species, cell types, and sequencing depth of any given experiment. 

Note that mitochondrial genes can be identified as starting with "MT-". 

```{r qc_filtering}

# The [[ ]] operator can add columns to object metadata. This is a great place to stash QC stats
pbmc_ser[["percent_mt"]] <- PercentageFeatureSet(pbmc_ser, pattern = "^MT-")

# Check out metadata now
head(pbmc_ser@meta.data)

# We can also plot values from metadata
VlnPlot(pbmc_ser, features = c("nFeature_RNA", "nCount_RNA", "percent_mt"), ncol = 3)

# We will filter to cells with greater than 200 genes and less than 2500 genes
# We will also exclude cells with greater than 5% MT reads
pbmc_ser <- subset(pbmc_ser, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent_mt < 5)

```

# Normalization 

```{r norm}

pbmc_ser <- NormalizeData(pbmc_ser, normalization.method = "LogNormalize", scale.factor = 10000)

```

# Identify highly variable features 

```{r features}

pbmc_ser <- FindVariableFeatures(pbmc_ser, selection.method = "vst", nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(pbmc_ser), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(pbmc_ser)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 / plot2

```

## Scale data and reduce dimensionality 

```{r scale_dim_red}

pbmc_ser <- ScaleData(pbmc_ser)

pbmc_ser <- RunPCA(pbmc_ser, features = VariableFeatures(object = pbmc_ser))

```

## Check out reduced dimensions in PCA space 

```{r dim_red_explore}

print(pbmc_ser[["pca"]], dims = 1:5, nfeatures = 5)

VizDimLoadings(pbmc_ser, dims = 1:2, reduction = "pca")

DimPlot(pbmc_ser, reduction = "pca")

DimHeatmap(pbmc_ser, dims = 1, cells = 500, balanced = TRUE)

ElbowPlot(pbmc_ser)

```

## Cluster cells 

```{r cluster}

pbmc_ser <- FindNeighbors(pbmc_ser, dims = 1:7)
pbmc_ser <- FindClusters(pbmc_ser, resolution = c(0.3,0.5,0.7))

dplyr::glimpse(pbmc_ser@meta.data)

Idents(pbmc_ser) <- "RNA_snn_res.0.3"

```

## Create UMAP for visualization 

```{r umap}

# If you haven't installed UMAP, you can do so via reticulate::py_install(packages = 'umap-learn')

pbmc_ser <- RunUMAP(pbmc_ser, dims = 1:7)

DimPlot(pbmc_ser, reduction = "umap",label=T)

```

## Evaluating differentially expressed genes 

```{r degs}

# find all markers of cluster 2
cluster2_markers <- FindMarkers(pbmc_ser, ident.1 = 2, min.pct = 0.25)
head(cluster2_markers, n = 5)

# find all markers distinguishing cluster 5 from clusters 0 and 3
cluster5_markers <- FindMarkers(pbmc_ser, ident.1 = 5, ident.2 = c(0, 3), min.pct = 0.25)
head(cluster5_markers, n = 5)

# find markers for every cluster compared to all remaining cells, report only the positive ones
pbmc_markers <- FindAllMarkers(pbmc_ser, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
pbmc_markers %>%
    group_by(cluster) %>%
    slice_max(n = 2, order_by = avg_log2FC)

# Heatmap of top DEGs across clusters 
pbmc_markers %>%
    group_by(cluster) %>%
    top_n(n = 10, wt = avg_log2FC) -> top10

pbmc_ser <- ScaleData(pbmc_ser,features=top10$gene)

DoHeatmap(pbmc_ser, features = top10$gene) + NoLegend()

```

## Identify cell types 

```{r cell_types}

FeaturePlot(pbmc_ser, features = c("MS4A1", "GNLY", "CD3E", "CD14", "FCER1A", "FCGR3A", "LYZ", "PPBP","CD8A"))

pbmc_meta <- pbmc_ser@meta.data %>%
    mutate(cell_types=RNA_snn_res.0.3) %>%
    mutate(cell_types=recode(cell_types,
        `0` = "Naive CD4 Tconv",
        `1` = "CD14 monocytes",
        `2` = "Mem CD4 Tconv",
        `3` = "B cells",
        `4` = "CD8 T cells",
        `5` = "CD16 monocytes",
        `6` = "NK cells",
        `7` = "DCs",
        `8` = "Platelets"
        )
    )

pbmc_meta %>%
    select(RNA_snn_res.0.3,cell_types) %>%
    table()

pbmc_ser[["cell_types"]] <- pbmc_meta$cell_types

DimPlot(pbmc_ser, group.by="cell_types", reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()

```

## Shortcuts

With the use of piping, we could have down much of this analysis in a few lines of code, as shown below. 

```{r piping}

pbmc_ser_quick <- CreateSeuratObject(counts=pbmc_data,project="pbmc3k",min.cells=3,min.features=200) 
pbmc_ser_quick[["percent_mt"]] <- PercentageFeatureSet(pbmc_ser_quick, pattern = "^MT-")

pbmc_ser_quick <- pbmc_ser_quick %>% 
    subset(., subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent_mt < 5) %>%
    NormalizeData(.) %>%
    FindVariableFeatures(.) %>%
    ScaleData(.) %>%
    RunPCA(.) 

ElbowPlot(pbmc_ser_quick)

pbmc_ser_quick <- pbmc_ser_quick %>%
    RunUMAP(.,dims=1:7) %>%
    FindNeighbors(.,dims=1:7) %>%
    FindClusters(.,res=c(0.3,0.5,0.7))

Idents(pbmc_ser_quick) <- "RNA_snn_res.0.3"

DimPlot(pbmc_ser_quick,group.by="RNA_snn_res.0.3",label=T)

```

## Saving data 

```{r saving}

# saveRDS(pbmc_ser,file="pbmc3k_vignette_final_output_231024.rds")

```